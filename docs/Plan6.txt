--Objects in the hierarchy--
The hierarchy will store references to the objects in the scene.
This will be stored in the object data, rather than a separate list.
It's important that each item knows where it should go, especially given how the actions can also be redone.

So for now, I think the plan is this. Objects should only be detached when they are deleted.
This means the action can be easily undone if necessary, as the object would just have to be re-attached if needed again.
When the command expires, the object can then be deleted.
So undoing an action like the add event would just require detaching the object, but remembering where it went.

I'm probably going to have to add a pointer to the object in the item struct.
This is because commands like the delete command operate on lots of objects.
Again, I would just have to detach the base item's objects, but I would still need pointers for the re-creation of the items.

So when each new item is appended, I can pass the data in that basically just holds a pointer to the object.

--Moving entities--
I want to start work on the entity move command.
This basically would work by selecting an item and then pushing a key, for example the M key.
Then as the user moves the mouse, the item would move with it.
They can also specify an axis to move the item on

This will also be a command, but I'm not entirely sure where the command should go.
It should probably go in the map class, because that's running a check function for input.
I suppose I'll have quite a few move commands by the time I'm done.

--Duplicating items--
So the way that duplicating items works is pretty straight forward.
You have to create a copy constructor for the object, which is basically just a constructor that takes in a reference to the object that needs to be copied.
The constructor can then go through the object and pull all the information from it to copy itself.
So as for the duplication command, it shouldn't be too difficult.

The copy command is probably going to have to duplicate the item again, and store that in the command manager or something.
When a paste function is needed, the item can be copied again and just pasted into that new place.
Furthermore, objects will have to inherit this copy method so that it can be performed correctly.

--Copy and pasting--
It's time to start thinking about how I plan to do copy and pasting.
Firstly, the program should take a copy of the item when it is copied.
I can't just take a pointer to the object, because if it's changed since it was copied then this copy would also change.
So because of this, I would need to do something like take a complete copy.
So I'm thinking that I could use the copy constructor to copy the object but not assign it to the scene.
When the object needs to be copied again, you can just copy it again, but actually do something with this item.

For this, I would need a constructor to actually hold the clipboard contents.
It might be a good idea to make a class that does this, for example HierarchyClipboardManager.
This would just contain a vector of objects that represent the clipboard.
You would have two functions, one that sets the clipboard and one that clears it. (the clear function will be run by the set command anyway)
The set command can just take an array list. This would probably have to do some searches to find the child items.
Then it would just store it like that.
Then the paste command would come along and do pretty much the same thing as the duplicate command.
When the copy command was called again, the objects in the clipboard can be deleted and replaced with the new ones.
Of course, the items in the clipboard won't be attached to anything in the scene, but they will still be there.

--Rays the planes--
From what it seems, the way to calculate the movement of an item is to surround it by large plane for each of it's axis.
I suppose that because I can just determine which axis I'm tracking anyway, I won't need to check the plane.
You can then check the intersection of the plane to see where the mouse is now.
You would basically just check the delta each time the mouse moves, and feed it into that.

So I've figured out how to do ray collisions.
The system with the plane will work just fine, considering that the entities will be locked to it anyway.
I'll have a function in the map class that assigns the visual drag things to the entity, so that's not too complicated.
The move command update will probably be where I'm going to do the update things.
I'll probably just have one plane for the entire map, and change it's orientation when needed.
I'll then pass the update map function the point of the current intersection, and the new position can be created from that.
